<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Assignment 5A for real</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <style>
      html, body {
  margin: 0;
  height: 100%;
}
#c {
  width: 100%;
  height: 100%;
  display: block;
}
    </style>
  </head>

  <body>
    <canvas id="c" data-engine="three.js r163"></canvas>
    <script  type="importmap">{
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
    }</script>
  <script type="module">
    
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import {MTLLoader} from 'three/addons/loaders/MTLLoader.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

function main() {

const canvas = document.querySelector( '#c' );
const renderer = new THREE.WebGLRenderer( { antialias: true, canvas } );

const fov = 45;
const aspect = 2; // the canvas default
const near = 0.1;
const far = 100;
const camera = new THREE.PerspectiveCamera( fov, aspect, near, far );
camera.position.set( 0, 10, 20 );

const controls = new OrbitControls( camera, canvas );
controls.target.set( 0, 5, 0 );
controls.update();

const scene = new THREE.Scene();
scene.background = new THREE.Color( 'black' );

{

  const planeSize = 4000;

  const loader = new THREE.TextureLoader();
  const texture = loader.load( 'https://threejs.org/manual/examples/resources/images/checker.png' );
  texture.colorSpace = THREE.SRGBColorSpace;
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.magFilter = THREE.NearestFilter;
  const repeats = planeSize / 200;
  texture.repeat.set( repeats, repeats );

  const planeGeo = new THREE.PlaneGeometry( planeSize, planeSize );
  const planeMat = new THREE.MeshPhongMaterial( {
    map: texture,
    side: THREE.DoubleSide,
  } );
  const mesh = new THREE.Mesh( planeGeo, planeMat );
  mesh.rotation.x = Math.PI * - .5;
  scene.add( mesh );

}

{
    const color = 0xbd3939;
		const intensity = 1114400;
		const light = new THREE.PointLight(color, intensity);
		light.position.set( -1000, 500, 1000 );
		scene.add( light );

		const helper = new THREE.PointLightHelper(light);
		scene.add( helper );

		function updateLight() {

			helper.update();

		}
  }

  class ColorGUIHelper {

constructor( object, prop ) {

  this.object = object;
  this.prop = prop;

}
get value() {

  return `#${this.object[ this.prop ].getHexString()}`;

}
set value( hexString ) {

  this.object[ this.prop ].set( hexString );

}

}

function makeXYZGUI( gui, vector3, name, onChangeFn ) {

const folder = gui.addFolder( name );
folder.add( vector3, 'x', - 10, 40 ).onChange( onChangeFn );
folder.add( vector3, 'y', 0, 40 ).onChange( onChangeFn );
folder.add( vector3, 'z', - 10, 40 ).onChange( onChangeFn );
folder.open();

}

{

const color = 0xFFFFFF;
const intensity = 0.1;
const light = new THREE.DirectionalLight( color, intensity );
light.position.set( 0, 10, 0 );
light.target.position.set( - 5, 0, 0 );
scene.add( light );
scene.add( light.target );

const helper = new THREE.DirectionalLightHelper( light );
scene.add( helper );

function updateLight() {

  light.target.updateMatrixWorld();
  helper.update();

}

updateLight();

const gui = new GUI();
gui.addColor( new ColorGUIHelper( light, 'color' ), 'value' ).name( 'color' );
gui.add( light, 'intensity', 0, 5, 0.01 );

makeXYZGUI( gui, light.position, 'position', updateLight );
makeXYZGUI( gui, light.target.position, 'target', updateLight );

}

function frameArea( sizeToFitOnScreen, boxSize, boxCenter, camera ) {

  const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
  const halfFovY = THREE.MathUtils.degToRad( camera.fov * .5 );
  const distance = halfSizeToFitOnScreen / Math.tan( halfFovY );
  // compute a unit vector that points in the direction the camera is now
  // in the xz plane from the center of the box
  const direction = ( new THREE.Vector3() )
    .subVectors( camera.position, boxCenter )
    .multiply( new THREE.Vector3( 1, 0, 1 ) )
    .normalize();

  // move the camera to a position distance units way from the center
  // in whatever direction the camera was from the center already
  camera.position.copy( direction.multiplyScalar( distance ).add( boxCenter ) );

  // pick some near and far values for the frustum that
  // will contain the box.
  camera.near = boxSize / 100;
  camera.far = boxSize * 100;

  camera.updateProjectionMatrix();

  // point the camera to look at the center of the box
  camera.lookAt( boxCenter.x, boxCenter.y, boxCenter.z );

}

{

  const mtlLoader = new MTLLoader();
  mtlLoader.load( 'https://threejs.org/manual/examples/resources/models/windmill_2/windmill-fixed.mtl', ( mtl ) => {

    mtl.preload();
    const objLoader = new OBJLoader();
    objLoader.setMaterials( mtl );
    objLoader.load( 'https://threejs.org/manual/examples/resources/models/windmill_2/windmill.obj', ( root ) => {

      scene.add( root );

      // compute the box that contains all the stuff
      // from root and below
      const box = new THREE.Box3().setFromObject( root );

      const boxSize = box.getSize( new THREE.Vector3() ).length();
      const boxCenter = box.getCenter( new THREE.Vector3() );

      // set the camera to frame the box
      frameArea( boxSize * 1.2, boxSize, boxCenter, camera );

      // update the Trackball controls to handle the new size
      controls.maxDistance = boxSize * 10;
      controls.target.copy( boxCenter );
      controls.update();

    } );

  } );

}



//first cylo -------------------------------------------
{
const cylinderRadiusTop = 200;
const cylinderRadiusBottom = 200;
const cylinderHeight = 1200;
const cylinderRadialSegments = 32;
const cylinderHeightSegments = 1;
const cylinderOpenEnded = false;

const cylinderGeo = new THREE.CylinderGeometry(
  cylinderRadiusTop,
  cylinderRadiusBottom,
  cylinderHeight,
  cylinderRadialSegments,
  cylinderHeightSegments,
  cylinderOpenEnded
);
const cylinderMat = new THREE.MeshPhongMaterial({ color: '#9e9e9e' });
const cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
cylinderMesh.position.set(-1200, 620, -1200); // Set position as needed
scene.add(cylinderMesh);
};

{
  const sphereRadius = 200;
const sphereWidthSegments = 32;
const sphereHeightSegments = 32;

const sphereGeo = new THREE.SphereGeometry(
  sphereRadius,
  sphereWidthSegments,
  sphereHeightSegments
);
const sphereMat = new THREE.MeshPhongMaterial({ color: '#9e9e9e' });
const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
sphereMesh.position.set(-1200, 1260, -1200); // Set position as needed
scene.add(sphereMesh);
};

// second cylo--------------------------------------------------------------------
{
const cylinderRadiusTop = 200;
const cylinderRadiusBottom = 200;
const cylinderHeight = 1200;
const cylinderRadialSegments = 32;
const cylinderHeightSegments = 1;
const cylinderOpenEnded = false;

const cylinderGeo = new THREE.CylinderGeometry(
  cylinderRadiusTop,
  cylinderRadiusBottom,
  cylinderHeight,
  cylinderRadialSegments,
  cylinderHeightSegments,
  cylinderOpenEnded
);
const cylinderMat = new THREE.MeshPhongMaterial({ color: '#9e9e9e' });
const cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
cylinderMesh.position.set(-1700, 620, -1200); // Set position as needed
scene.add(cylinderMesh);
};

{
  const sphereRadius = 200;
const sphereWidthSegments = 32;
const sphereHeightSegments = 32;

const sphereGeo = new THREE.SphereGeometry(
  sphereRadius,
  sphereWidthSegments,
  sphereHeightSegments
);
const sphereMat = new THREE.MeshPhongMaterial({ color: '#9e9e9e' });
const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
sphereMesh.position.set(-1700, 1260, -1200); // Set position as needed
scene.add(sphereMesh);
};


// sun
const SunsphereRadius = 300;
const SunsphereWidthSegments = 32;
const SunsphereHeightSegments = 32;

const SunsphereGeo = new THREE.SphereGeometry(
  SunsphereRadius,
  SunsphereWidthSegments,
  SunsphereHeightSegments
);


const SunsphereMat = new THREE.MeshPhongMaterial({ color: '#f2be07', emissive: '#fcba03', emissiveIntensity: 1  });
const SunsphereMesh = new THREE.Mesh(SunsphereGeo, SunsphereMat);
SunsphereMesh.position.set(-1300, 2660, -1300); // Set position as needed
scene.add(SunsphereMesh);


    const Suncolor = 0xf2be07;
		const Sunintensity = 11114400;
		const Sunlight = new THREE.PointLight(Suncolor, Sunintensity);
		Sunlight.position.set( -1300, 2660, -1600);
		scene.add( Sunlight );

		const Sunhelper = new THREE.PointLightHelper(Sunlight);
		scene.add( Sunhelper );

		function updateLight() {

			Sunhelper.update();

		}



let sunX = -1300;
const sunSpeed = 0.001; // Constant movement speed along the x-axis
let rotationDirection = 1; // Initial rotation direction (1 for clockwise, -1 for counterclockwise)

// Update the position of the sphere in the animation loop
function animateSun() {
    // Move the sun along the x-axis
    sunX += sunSpeed * rotationDirection;

    // Check if the sun has reached the boundaries
    const boundaryRight = 1300; // Right boundary
    const boundaryLeft = -1300; // Left boundary
    if (sunX >= boundaryRight){
        // Reverse movement direction
        rotationDirection *= -1;

      
    }

    else if (sunX < boundaryLeft){
      rotationDirection *= -1;
      sunX = -1300;

    }

    // Update the position of the sphere
    SunsphereMesh.position.x = sunX;
    Sunlight.position.x = sunX;


    // Request the next frame
    requestAnimationFrame(animateSun);
}



//barn 
{
const cubeSize = 400;
const cubeGeo = new THREE.BoxGeometry( cubeSize, cubeSize, 950 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#ff1100' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( -1300, 200, -100 );
scene.add( mesh );
};

// barn top 
{
  const cylinderRadiusTop = 200;
const cylinderRadiusBottom = 200;
const cylinderHeight = 940;
const cylinderRadialSegments = 32;
const cylinderHeightSegments = 1;
const cylinderOpenEnded = false;

const cylinderGeo = new THREE.CylinderGeometry(
  cylinderRadiusTop,
  cylinderRadiusBottom,
  cylinderHeight,
  cylinderRadialSegments,
  cylinderHeightSegments,
  cylinderOpenEnded
);
const cylinderMat = new THREE.MeshPhongMaterial({ color: '#f7dedc' });
const cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
cylinderMesh.rotation.x  = Math.PI / 2
cylinderMesh.position.set( -1300, 400, -100 ); // Set position as needed
scene.add(cylinderMesh);
};

// water trough 
{
const cylinderRadiusTop = 300;
const cylinderRadiusBottom = 300;
const cylinderHeight = 200;
const cylinderRadialSegments = 32;
const cylinderHeightSegments = 1;
const cylinderOpenEnded = false;

const cylinderGeo = new THREE.CylinderGeometry(
  cylinderRadiusTop,
  cylinderRadiusBottom,
  cylinderHeight,
  cylinderRadialSegments,
  cylinderHeightSegments,
  cylinderOpenEnded
);
const cylinderMat = new THREE.MeshPhongMaterial({ color: '#676e69' });
const cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
cylinderMesh.position.set(-1200, 100, 1200); // Set position as needed
scene.add(cylinderMesh);
};

//water inside trough ??
{
  const cylinderRadiusTop = 280;
const cylinderRadiusBottom = 280;
const cylinderHeight = 210;
const cylinderRadialSegments = 32;
const cylinderHeightSegments = 1;
const cylinderOpenEnded = false;

const cylinderGeo = new THREE.CylinderGeometry(
  cylinderRadiusTop,
  cylinderRadiusBottom,
  cylinderHeight,
  cylinderRadialSegments,
  cylinderHeightSegments,
  cylinderOpenEnded
);
const cylinderMat = new THREE.MeshPhongMaterial({ color: '#268ded' });
const cylinderMesh = new THREE.Mesh(cylinderGeo, cylinderMat);
cylinderMesh.position.set(-1200, 100, 1200); // Set position as needed
scene.add(cylinderMesh);
};

//dirt field 1
{
const cubeGeo = new THREE.BoxGeometry( 300, 10, 1300 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#6b4612' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( -600, 10, 1200 );
scene.add( mesh );
};

// crops on field 1
{
  const cubeGeo = new THREE.BoxGeometry( 100, 10, 1150 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#126b22' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( -600, 20, 1200 );
scene.add( mesh );
}


//dirt field 2
{
const cubeGeo = new THREE.BoxGeometry( 300, 10, 1300 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#6b4612' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( -200, 10, 1200 );
scene.add( mesh );
};

// crops on field 2
{
  const cubeGeo = new THREE.BoxGeometry( 100, 10, 1150 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#126b22' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( -200, 20, 1200 );
scene.add( mesh );
}

//dirt field 3
{
const cubeGeo = new THREE.BoxGeometry( 300, 10, 1300 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#6b4612' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 200, 10, 1200 );
scene.add( mesh );
};

// crops on field 3
{
  const cubeGeo = new THREE.BoxGeometry( 100, 10, 1150 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#126b22' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 200, 20, 1200 );
scene.add( mesh );
}

//dirt field 4
{
const cubeGeo = new THREE.BoxGeometry( 300, 10, 1300 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#6b4612' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 600, 10, 1200 );
scene.add( mesh );
};

// crops on field 4
{
  const cubeGeo = new THREE.BoxGeometry( 100, 10, 1150 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#126b22' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 600, 20, 1200 );
scene.add( mesh );
}

//dirt field 5
{
const cubeGeo = new THREE.BoxGeometry( 300, 10, 1300 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#6b4612' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 1000, 10, 1200 );
scene.add( mesh );
};

// crops on field 5
{
  const cubeGeo = new THREE.BoxGeometry( 100, 10, 1150 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#126b22' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 1000, 20, 1200 );
scene.add( mesh );
};

// house roof 
{
  const pyramidSize = 1100;
const pyramidHeight = 300;

const pyramidGeo = new THREE.ConeGeometry(
  pyramidSize / Math.sqrt(2), // Radius
  pyramidHeight, // Height
  4
);
const pyramidMat = new THREE.MeshPhongMaterial({ color: '#b37432' });
const pyramidMesh = new THREE.Mesh(pyramidGeo, pyramidMat);
pyramidMesh.rotation.y  = Math.PI / 4
pyramidMesh.position.set(1200, 660, -1200); // Set position as needed
//pyramidMesh.rotation.z(20);
scene.add(pyramidMesh);
};

// house itslef
{

const cubeGeo = new THREE.BoxGeometry( 1000, 500, 800 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#faf084' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 1200, 250, -1200 );
scene.add( mesh );

};

// house door
{

const cubeGeo = new THREE.BoxGeometry( 140, 350, 90 );
const cubeMat = new THREE.MeshPhongMaterial( { color: '#9e2b08' } );
const mesh = new THREE.Mesh( cubeGeo, cubeMat );
mesh.position.set( 1350, 160, -840 );
scene.add( mesh );

};
const loader = new THREE.TextureLoader();
function loadColorTexture( path ) {

  const texture = loader.load( path );
  texture.colorSpace = THREE.SRGBColorSpace;
  return texture;

}

{
const flowerboxWidth = 130;
const flowerboxHeight = 130;
const flowerboxDepth = 130;
const flowergeometry = new THREE.BoxGeometry( flowerboxWidth, flowerboxHeight, flowerboxDepth );

	

	const materials = [
		new THREE.MeshBasicMaterial( { map: loadColorTexture( 'https://threejs.org/manual/examples/resources/images/flower-1.jpg' ) } ),
		new THREE.MeshBasicMaterial( { map: loadColorTexture( 'https://threejs.org/manual/examples/resources/images/flower-2.jpg' ) } ),
		new THREE.MeshBasicMaterial( { map: loadColorTexture( 'https://threejs.org/manual/examples/resources/images/flower-3.jpg' ) } ),
		new THREE.MeshBasicMaterial( { map: loadColorTexture( 'https://threejs.org/manual/examples/resources/images/flower-4.jpg' ) } ),
		new THREE.MeshBasicMaterial( { map: loadColorTexture( 'https://threejs.org/manual/examples/resources/images/flower-5.jpg' ) } ),
		new THREE.MeshBasicMaterial( { map: loadColorTexture( 'https://threejs.org/manual/examples/resources/images/flower-6.jpg' ) } ),
	];

	const flowercube1 = new THREE.Mesh( flowergeometry, materials );
  const flowercube2 = new THREE.Mesh( flowergeometry, materials );
  const flowercube3 = new THREE.Mesh( flowergeometry, materials );
  const flowercube4 = new THREE.Mesh( flowergeometry, materials );
  const flowercube5 = new THREE.Mesh( flowergeometry, materials );
  const flowercube6 = new THREE.Mesh( flowergeometry, materials );
  const flowercube7 = new THREE.Mesh( flowergeometry, materials );
  const flowercube8 = new THREE.Mesh( flowergeometry, materials );
  const flowercube9 = new THREE.Mesh( flowergeometry, materials );
  const flowercube10 = new THREE.Mesh( flowergeometry, materials );
	flowercube1.position.set(1350, 80, 840);
  flowercube2.position.set(1550, 80, 740);
  flowercube3.position.set(1550, 80, 940);
  flowercube4.position.set(1350, 80, 1040);
  flowercube5.position.set(1550, 80, 1140);
  flowercube6.position.set(1350, 80, 1240);
  flowercube7.position.set(1550, 80, 1340);
  flowercube8.position.set(1350, 80, 1440);
  flowercube9.position.set(1550, 80, 1540);
  flowercube10.position.set(1350, 80, 1640);
  scene.add( flowercube1 );
  scene.add( flowercube2 );
  scene.add( flowercube3 );
  scene.add( flowercube4 );
  scene.add( flowercube5 );
  scene.add( flowercube6 );
  scene.add( flowercube7 );
  scene.add( flowercube8 );
  scene.add( flowercube9 );
  scene.add( flowercube10 );
	
};
{

const loader = new THREE.CubeTextureLoader();
const texture = loader.load( [

'yellowcloud_bk.jpg',
'yellowcloud_ft.jpg',
'yellowcloud_up.jpg',
'yellowcloud_dn.jpg',
'yellowcloud_rt.jpg',
'yellowcloud_lf.jpg',

] );
scene.background = texture;

};

function resizeRendererToDisplaySize( renderer ) {

  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if ( needResize ) {

    renderer.setSize( width, height, false );

  }

  return needResize;

}

function render() {

  if ( resizeRendererToDisplaySize( renderer ) ) {

    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();

  }
  
  animateSun();
  renderer.render( scene, camera );

  requestAnimationFrame( render );

}

requestAnimationFrame( render );

}

main();
    </script>

  
  </body>

</html>
